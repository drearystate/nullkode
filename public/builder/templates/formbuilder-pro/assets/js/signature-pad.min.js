/**
 * Signature Pad Fallback for FormBuilder Pro
 * Basic signature functionality when CDN is not available
 */

class SignaturePad {
    constructor(canvas, options = {}) {
        this.canvas = canvas;
        this.ctx = canvas.getContext('2d');
        this.options = {
            penColor: options.penColor || 'rgb(0, 0, 0)',
            backgroundColor: options.backgroundColor || 'rgba(0,0,0,0)',
            minWidth: options.minWidth || 0.5,
            maxWidth: options.maxWidth || 2.5,
            throttle: options.throttle || 16,
            minDistance: options.minDistance || 5,
            ...options
        };
        
        this.isDrawing = false;
        this.isEmpty = true;
        this.points = [];
        this.data = [];
        
        this.init();
    }
    
    init() {
        this.canvas.style.touchAction = 'none';
        this.canvas.style.msTouchAction = 'none';
        
        this.resizeCanvas();
        this.bindEvents();
    }
    
    resizeCanvas() {
        const ratio = Math.max(window.devicePixelRatio || 1, 1);
        const rect = this.canvas.getBoundingClientRect();
        
        this.canvas.width = rect.width * ratio;
        this.canvas.height = rect.height * ratio;
        this.canvas.style.width = rect.width + 'px';
        this.canvas.style.height = rect.height + 'px';
        
        this.ctx.scale(ratio, ratio);
        this.ctx.lineCap = 'round';
        this.ctx.lineJoin = 'round';
        this.ctx.strokeStyle = this.options.penColor;
        this.ctx.fillStyle = this.options.backgroundColor;
        
        this.clear();
    }
    
    bindEvents() {
        // Mouse events
        this.canvas.addEventListener('mousedown', this.handleMouseDown.bind(this));
        this.canvas.addEventListener('mousemove', this.handleMouseMove.bind(this));
        this.canvas.addEventListener('mouseup', this.handleMouseUp.bind(this));
        
        // Touch events
        this.canvas.addEventListener('touchstart', this.handleTouchStart.bind(this));
        this.canvas.addEventListener('touchmove', this.handleTouchMove.bind(this));
        this.canvas.addEventListener('touchend', this.handleTouchEnd.bind(this));
        
        // Prevent scrolling on touch
        this.canvas.addEventListener('touchstart', e => e.preventDefault());
        this.canvas.addEventListener('touchmove', e => e.preventDefault());
        this.canvas.addEventListener('touchend', e => e.preventDefault());
    }
    
    handleMouseDown(event) {
        this.isDrawing = true;
        this.isEmpty = false;
        const point = this.getPointFromEvent(event);
        this.addPoint(point);
    }
    
    handleMouseMove(event) {
        if (!this.isDrawing) return;
        const point = this.getPointFromEvent(event);
        this.addPoint(point);
    }
    
    handleMouseUp() {
        this.isDrawing = false;
        this.finishStroke();
    }
    
    handleTouchStart(event) {
        const touch = event.touches[0];
        const mouseEvent = new MouseEvent('mousedown', {
            clientX: touch.clientX,
            clientY: touch.clientY
        });
        this.canvas.dispatchEvent(mouseEvent);
    }
    
    handleTouchMove(event) {
        const touch = event.touches[0];
        const mouseEvent = new MouseEvent('mousemove', {
            clientX: touch.clientX,
            clientY: touch.clientY
        });
        this.canvas.dispatchEvent(mouseEvent);
    }
    
    handleTouchEnd(event) {
        const mouseEvent = new MouseEvent('mouseup', {});
        this.canvas.dispatchEvent(mouseEvent);
    }
    
    getPointFromEvent(event) {
        const rect = this.canvas.getBoundingClientRect();
        return {
            x: event.clientX - rect.left,
            y: event.clientY - rect.top,
            time: Date.now(),
            pressure: event.pressure || event.force || 0
        };
    }
    
    addPoint(point) {
        this.points.push(point);
        
        if (this.points.length > 2) {
            // Draw smooth curve
            const lastTwoPoints = this.points.slice(-2);
            const controlPoint = lastTwoPoints[0];
            const endPoint = {
                x: (lastTwoPoints[0].x + lastTwoPoints[1].x) / 2,
                y: (lastTwoPoints[0].y + lastTwoPoints[1].y) / 2
            };
            
            this.drawCurve(controlPoint, endPoint);
        }
        
        this.data.push(point);
    }
    
    drawCurve(controlPoint, endPoint) {
        this.ctx.beginPath();
        this.ctx.moveTo(this.points[this.points.length - 3].x, this.points[this.points.length - 3].y);
        this.ctx.quadraticCurveTo(controlPoint.x, controlPoint.y, endPoint.x, endPoint.y);
        this.ctx.lineWidth = this.options.minWidth;
        this.ctx.stroke();
    }
    
    finishStroke() {
        if (this.points.length < 3) {
            const point = this.points[0];
            this.ctx.beginPath();
            this.ctx.arc(point.x, point.y, this.options.minWidth / 2, 0, 2 * Math.PI);
            this.ctx.fill();
        }
        
        this.points = [];
    }
    
    clear() {
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        this.isEmpty = true;
        this.data = [];
        this.points = [];
    }
    
    toDataURL(type = 'image/png', encoderOptions = 0.92) {
        return this.canvas.toDataURL(type, encoderOptions);
    }
    
    fromDataURL(dataUrl, options = {}) {
        return new Promise((resolve, reject) => {
            const image = new Image();
            const ratio = options.ratio || window.devicePixelRatio || 1;
            const width = options.width || this.canvas.width / ratio;
            const height = options.height || this.canvas.height / ratio;
            
            image.onload = () => {
                this.clear();
                this.ctx.drawImage(image, 0, 0, width, height);
                this.isEmpty = false;
                resolve();
            };
            
            image.onerror = reject;
            image.src = dataUrl;
        });
    }
    
    toData() {
        return this.data;
    }
    
    fromData(pointGroups) {
        this.clear();
        
        pointGroups.forEach(pointGroup => {
            this.ctx.beginPath();
            pointGroup.forEach((point, i) => {
                if (i === 0) {
                    this.ctx.moveTo(point.x, point.y);
                } else {
                    this.ctx.lineTo(point.x, point.y);
                }
            });
            this.ctx.stroke();
        });
        
        this.isEmpty = pointGroups.length === 0;
        this.data = pointGroups;
    }
    
    on(event, callback) {
        // Simple event system
        if (!this.events) this.events = {};
        if (!this.events[event]) this.events[event] = [];
        this.events[event].push(callback);
    }
    
    off(event, callback) {
        if (!this.events || !this.events[event]) return;
        const index = this.events[event].indexOf(callback);
        if (index > -1) {
            this.events[event].splice(index, 1);
        }
    }
    
    trigger(event, ...args) {
        if (!this.events || !this.events[event]) return;
        this.events[event].forEach(callback => callback(...args));
    }
}

// Make it available globally
window.SignaturePad = SignaturePad;

console.log('âœ… Signature Pad fallback library loaded successfully');
